(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{372:function(e,n,o){e.exports=o.p+"assets/img/PayloadCodeMap.51ef8c0a.png"},373:function(e,n,o){e.exports=o.p+"assets/img/PayloadFeaturesCodeMap.e0e898e0.png"},413:function(e,n,o){"use strict";o.r(n);var a=o(27),t=Object(a.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"payloads"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#payloads"}},[e._v("#")]),e._v(" Payloads")]),e._v(" "),a("h2",{attrs:{id:"standard-payloads"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#standard-payloads"}},[e._v("#")]),e._v(" Standard payloads")]),e._v(" "),a("p",[e._v("Built into the Blockcore foundation there are some payloads used to handle the peer to peer protocol and connections of nodes, and exchange of blockchain data.")]),e._v(" "),a("p",[e._v("Here are the built in primary payload types with their command names in parentheses:")]),e._v(" "),a("ul",[a("li",[e._v('AddrPayload ("addr")')]),e._v(" "),a("li",[e._v('BlockPayload ("block")')]),e._v(" "),a("li",[e._v('GetAddrPayload ("getaddr")')]),e._v(" "),a("li",[e._v('GetBlocksPayload ("getblocks")')]),e._v(" "),a("li",[e._v('GetDataPayload ("getdata")')]),e._v(" "),a("li",[e._v('GetHeadersPayload ("getheaders")')]),e._v(" "),a("li",[e._v('GetProvenHeadersPayload ("getprovhdr")')]),e._v(" "),a("li",[e._v('HaveWitnessPayload ("havewitness")')]),e._v(" "),a("li",[e._v('HeadersPayload ("headers")')]),e._v(" "),a("li",[e._v('InvPayload ("inv")')]),e._v(" "),a("li",[e._v('MempoolPayload ("mempool")')]),e._v(" "),a("li",[e._v("NotFoundPayload")]),e._v(" "),a("li",[e._v('PingPayload ("ping")')]),e._v(" "),a("li",[e._v('PongPayload ("pong")')]),e._v(" "),a("li",[e._v('ProvenHeadersPayload ("provhdr")')]),e._v(" "),a("li",[e._v('RejectPayload ("reject")')]),e._v(" "),a("li",[e._v('SendHeadersPayload ("sendheaders")')]),e._v(" "),a("li",[e._v('TxPayload ("tx")')]),e._v(" "),a("li",[e._v("UnknowPayload")]),e._v(" "),a("li",[e._v('VerAckPayload ("verack")')]),e._v(" "),a("li",[e._v('VersionPayload ("version")')])]),e._v(" "),a("p",[e._v("Here are payload types defined in features:")]),e._v(" "),a("ul",[a("li",[e._v('FeeFilterPayload ("feefilter")')]),e._v(" "),a("li",[e._v('PoAHeaderPayload ("poahdr")')]),e._v(" "),a("li",[e._v('StoragePayload ("storage")')]),e._v(" "),a("li",[e._v('StorageInvPayload ("storageinv")')])]),e._v(" "),a("p",[e._v("Here is a code map of the payload in the Blockcore assembly:")]),e._v(" "),a("figure",[a("img",{attrs:{src:o(372),alt:""}})]),e._v(" "),a("p",[e._v("Here is a code map of the custom payload types defined in features:")]),e._v(" "),a("figure",[a("img",{attrs:{src:o(373),alt:""}})]),e._v(" "),a("h2",{attrs:{id:"your-own-custom-payload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#your-own-custom-payload"}},[e._v("#")]),e._v(" Your own custom payload")]),e._v(" "),a("p",[e._v("You can implement your own custom payloads, which is a great way to build a communication solution between nodes connected in a peer to peer fashion.")]),e._v(" "),a("p",[e._v("You can use these custom features to build chat solutions, data transfer solutions or any other logic that can be useful for a network of nodes.")]),e._v(" "),a("p",[e._v("All you need is one or multiple payload types and an behavior class.")]),e._v(" "),a("p",[e._v("Example of a payload. You should define these classes inside your own custom feature.")]),e._v(" "),a("div",{staticClass:"language-C# extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// This sample is copied from the "ping" payload.\nusing NBitcoin;\n\nnamespace Blockcore.P2P.Protocol.Payloads\n{\n    [Payload("storage")]\n    public class StoragePayload : Payload\n    {\n        private uint[] items;\n\n        public uint[] Items { get { return this.items; } set { this.items = value; } }\n\n        public StoragePayload(uint[] items)\n        {\n            this.items = items;\n        }\n\n        public override void ReadWriteCore(BitcoinStream stream)\n        {\n            stream.ReadWrite(ref this.items);\n        }\n\n        public override string ToString()\n        {\n            return base.ToString() + " : " + this.Items;\n        }\n    }\n}\n')])])]),a("p",[e._v("Then you also need a behavior that will process messages.")]),e._v(" "),a("div",{staticClass:"language-C# extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Blockcore.Connection;\nusing Blockcore.Interfaces;\nusing Blockcore.P2P.Peer;\nusing Blockcore.P2P.Protocol;\nusing Blockcore.P2P.Protocol.Behaviors;\nusing Blockcore.P2P.Protocol.Payloads;\nusing Blockcore.Signals;\nusing Blockcore.Utilities;\nusing Microsoft.Extensions.Logging;\nusing NBitcoin;\n\nnamespace Blockcore.Features.Storage\n{\n    /// <summary>\n    /// Peer behavior for memory pool.\n    /// Provides message handling of notifications from attached peer.\n    /// </summary>\n    public class StorageBehavior : NetworkPeerBehavior\n    {\n        /// <summary>Connection manager for managing peer connections.</summary>\n        private readonly IConnectionManager connectionManager;\n\n        /// <summary>Provider of IBD state.</summary>\n        private readonly IInitialBlockDownloadState initialBlockDownloadState;\n\n        /// <summary>Instance logger for the memory pool behavior component.</summary>\n        private readonly ILogger logger;\n\n        /// <summary>Factory used to create the logger for this component.</summary>\n        private readonly ILoggerFactory loggerFactory;\n\n        /// <summary>The network that this component is running on.</summary>\n        private readonly Network network;\n\n        /// <summary>\n        /// Locking object for memory pool behaviour.\n        /// </summary>\n        private readonly object lockObject;\n\n        /// <summary>\n        /// The min fee the peer asks to relay transactions.\n        /// </summary>\n        public Money MinFeeFilter { get; set; }\n\n        public StorageBehavior(\n            IConnectionManager connectionManager,\n            IInitialBlockDownloadState initialBlockDownloadState,\n            ILoggerFactory loggerFactory,\n            Network network)\n        {\n            this.connectionManager = connectionManager;\n            this.initialBlockDownloadState = initialBlockDownloadState;\n            this.logger = loggerFactory.CreateLogger(this.GetType().FullName);\n            this.loggerFactory = loggerFactory;\n            this.network = network;\n            this.lockObject = new object();\n        }\n\n        /// <inheritdoc />\n        protected override void AttachCore()\n        {\n            this.AttachedPeer.MessageReceived.Register(this.OnMessageReceivedAsync);\n        }\n\n        /// <inheritdoc />\n        protected override void DetachCore()\n        {\n            this.AttachedPeer.MessageReceived.Unregister(this.OnMessageReceivedAsync);\n        }\n\n        /// <inheritdoc />\n        public override object Clone()\n        {\n            return new StorageBehavior(this.connectionManager, this.initialBlockDownloadState, this.loggerFactory, this.network);\n        }\n\n        private async Task OnMessageReceivedAsync(INetworkPeer peer, IncomingMessage message)\n        {\n            try\n            {\n                await this.ProcessMessageAsync(peer, message).ConfigureAwait(false);\n            }\n            catch (OperationCanceledException)\n            {\n                this.logger.LogTrace("(-)[CANCELED_EXCEPTION]");\n                return;\n            }\n            catch (Exception ex)\n            {\n                this.logger.LogError("Exception occurred: {0}", ex.ToString());\n                throw;\n            }\n        }\n\n        private async Task ProcessMessageAsync(INetworkPeer peer, IncomingMessage message)\n        {\n            try\n            {\n                switch (message.Message.Payload)\n                {\n                    case StoragePayload storagePayload:\n                        await this.ProcessStorageInPayloadAsync(peer, storagePayload).ConfigureAwait(false);\n                        break;\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                this.logger.LogTrace("(-)[CANCELED_EXCEPTION]");\n                return;\n            }\n        }\n\n        private async Task ProcessStorageInPayloadAsync(INetworkPeer peer, StoragePayload message)\n        {\n            Guard.NotNull(peer, nameof(peer));\n\n            if (peer != this.AttachedPeer)\n            {\n                this.logger.LogDebug("Attached peer \'{0}\' does not match the originating peer \'{1}\'.", this.AttachedPeer?.RemoteSocketEndpoint, peer.RemoteSocketEndpoint);\n                this.logger.LogTrace("(-)[PEER_MISMATCH]");\n                return;\n            }\n\n            List<uint> list = new List<uint>();\n            list.Add(1);\n            list.Add(2);\n            list.Add(3);\n\n            await this.SendStorageAsync(peer, list);\n        }\n\n        private async Task SendStorageAsync(INetworkPeer peer, List<uint> storageList)\n        {\n            var queue = new Queue<uint>(storageList);\n\n            while (queue.Count > 0)\n            {\n                uint[] items = queue.TakeAndRemove(5).ToArray();\n\n                if (peer.IsConnected)\n                {\n                    this.logger.LogDebug("Sending items to peer \'{0}\'.", peer.RemoteSocketEndpoint);\n                    await peer.SendMessageAsync(new StoragePayload(items)).ConfigureAwait(false);\n                }\n            }\n        }\n\n        public async Task SendTrickleAsync()\n        {\n            INetworkPeer peer = this.AttachedPeer;\n            if (peer == null)\n            {\n                this.logger.LogTrace("(-)[NO_PEER]");\n                return;\n            }\n\n            this.logger.LogDebug("Sending storage inventory to peer \'{0}\'.", peer.RemoteSocketEndpoint);\n            try\n            {\n                // Sample data to send.\n                List<uint> list = new List<uint>();\n                list.Add(1);\n                list.Add(2);\n\n                await this.SendStorageAsync(peer, list).ConfigureAwait(false);\n            }\n            catch (OperationCanceledException)\n            {\n                this.logger.LogTrace("(-)[CANCELED_EXCEPTION]");\n                return;\n            }\n        }\n    }\n}\n\n')])])]),a("p",[e._v("Then finally you need your custom feature:")]),e._v(" "),a("div",{staticClass:"language-C# extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('using System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Blockcore.AsyncWork;\nusing Blockcore.Builder;\nusing Blockcore.Builder.Feature;\nusing Blockcore.Configuration.Logging;\nusing Blockcore.Connection;\nusing Blockcore.Features.Storage.Persistence;\nusing Blockcore.P2P.Peer;\nusing Blockcore.P2P.Protocol.Payloads;\nusing Blockcore.Utilities;\nusing Microsoft.Extensions.DependencyInjection;\n\nnamespace Blockcore.Features.Storage\n{\n    public class StorageFeature : FullNodeFeature\n    {\n        /// <summary>The async loop we need to wait upon before we can shut down this manager.</summary>\n        private IAsyncLoop asyncLoop;\n\n        /// <summary>Factory for creating background async loop tasks.</summary>\n        private readonly IAsyncProvider asyncProvider;\n\n        /// <summary>\n        /// Connection manager injected dependency.\n        /// </summary>\n        private readonly IConnectionManager connection;\n\n        /// <summary>Global application life cycle control - triggers when application shuts down.</summary>\n        private readonly INodeLifetime nodeLifetime;\n\n        private readonly PayloadProvider payloadProvider;\n\n        private readonly StorageBehavior storageBehavior;\n\n        public StorageFeature(\n            IConnectionManager connection,\n            INodeLifetime nodeLifetime,\n            IAsyncProvider asyncProvider,\n            PayloadProvider payloadProvider,\n            StorageBehavior storageBehavior)\n        {\n            this.connection = connection;\n            this.nodeLifetime = nodeLifetime;\n            this.payloadProvider = payloadProvider;\n            this.asyncProvider = asyncProvider;\n            this.storageBehavior = storageBehavior;\n        }\n\n        public override Task InitializeAsync()\n        {\n            // Register the behavior.\n            this.connection.Parameters.TemplateBehaviors.Add(this.storageBehavior);\n\n            // Register the payload types.\n            this.payloadProvider.AddPayload(typeof(StoragePayload));\n\n            // Make a worker that will filter connected knows that has announced our custom payload behavior.\n            this.asyncLoop = this.asyncProvider.CreateAndRunAsyncLoop("Storage.SyncWorker", async token =>\n            {\n                IReadOnlyNetworkPeerCollection peers = this.connection.ConnectedPeers;\n\n                if (!peers.Any())\n                {\n                    return;\n                }\n\n                // Announce the blocks on each nodes behavior which supports relaying.\n                IEnumerable<StorageBehavior> behaviors = peers.Where(x => x.PeerVersion?.Relay ?? false)\n                                                              .Select(x => x.Behavior<StorageBehavior>())\n                                                              .Where(x => x != null)\n                                                              .ToList();\n\n                foreach (StorageBehavior behavior in behaviors)\n                {\n                    await behavior.SendTrickleAsync().ConfigureAwait(false);\n                }\n            },\n                this.nodeLifetime.ApplicationStopping,\n                repeatEvery: TimeSpans.FiveSeconds,\n                startAfter: TimeSpans.TenSeconds);\n\n            return Task.CompletedTask;\n        }\n    }\n\n    /// <summary>\n    /// A class providing extension methods for <see cref="IFullNodeBuilder"/>.\n    /// </summary>\n    public static class FullNodeBuilderStorageExtension\n    {\n        public static IFullNodeBuilder UseStorage(this IFullNodeBuilder fullNodeBuilder)\n        {\n            LoggingConfiguration.RegisterFeatureNamespace<StorageFeature>("storage");\n\n            fullNodeBuilder.ConfigureFeature(features =>\n            {\n                features\n                   .AddFeature<StorageFeature>()\n                   .FeatureServices(services =>\n                   {\n                       services.AddSingleton<IDataStore, DataStore>();\n                       services.AddSingleton<StorageBehavior>();\n                   });\n            });\n\n            return fullNodeBuilder;\n        }\n    }\n}\n\n')])])]),a("p",[e._v("This is basically all you need to start building custom data payload features ontop of your network of Blockcore nodes.")])])}),[],!1,null,null,null);n.default=t.exports}}]);